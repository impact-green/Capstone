{"ast":null,"code":"/*\n * Swipe 2.0.0\n * Brad Birdsall\n * https://github.com/thebird/Swipe\n * Copyright 2013-2015, MIT License\n *\n */\n(function (root, factory) {\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Swipe = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  return function Swipe(container, options) {\n    // utilities\n    var noop = function noop() {}; // simple no operation function\n\n\n    var offloadFn = function offloadFn(fn) {\n      setTimeout(fn || noop, 0);\n    }; // offload a functions execution\n    // check browser capabilities\n\n\n    var browser = {\n      addEventListener: !!window.addEventListener,\n      touch: 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,\n      transitions: function (temp) {\n        var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n\n        for (var i in props) {\n          if (temp.style[props[i]] !== undefined) return true;\n        }\n\n        return false;\n      }(document.createElement('swipe'))\n    }; // quit if no root element\n\n    if (!container) return;\n    var element = container.children[0];\n    var slides, slidePos, width, length;\n    options = options || {};\n    var index = parseInt(options.startSlide, 10) || 0;\n    var speed = options.speed || 300;\n    var widthOfSiblingSlidePreview = parseInt(options.widthOfSiblingSlidePreview, 10) || 0;\n    var continuous = options.continuous = options.continuous !== undefined ? options.continuous : true;\n\n    function _setup() {\n      // cache slides\n      slides = element.children;\n      length = slides.length; // set continuous to false if only one slide\n\n      continuous = slides.length < 2 ? false : options.continuous; // create an array to store current positions of each slide\n\n      slidePos = new Array(slides.length); // determine width of each slide\n\n      width = Math.round(container.getBoundingClientRect().width || container.offsetWidth) - widthOfSiblingSlidePreview * 2;\n      element.style.width = slides.length * width + 'px'; // stack elements\n\n      var pos = slides.length;\n\n      while (pos--) {\n        var slide = slides[pos];\n        slide.style.width = width + 'px';\n        slide.setAttribute('data-index', pos);\n\n        if (browser.transitions) {\n          slide.style.left = pos * -width + widthOfSiblingSlidePreview + 'px';\n          move(pos, index > pos ? -width : index < pos ? width : 0, 0);\n        }\n      } // reposition elements before and after index\n\n\n      if (continuous && browser.transitions) {\n        move(circle(index - 1), -width, 0);\n        move(circle(index + 1), width, 0);\n      }\n\n      if (!browser.transitions) element.style.left = index * -width + widthOfSiblingSlidePreview + 'px';\n      container.style.visibility = 'visible';\n    }\n\n    function _prev() {\n      if (continuous) _slide(index - 1);else if (index) _slide(index - 1);\n    }\n\n    function _next() {\n      if (continuous) _slide(index + 1);else if (index < slides.length - 1) _slide(index + 1);\n    }\n\n    function circle(index) {\n      // a simple positive modulo using slides.length\n      return (slides.length + index % slides.length) % slides.length;\n    }\n\n    function _slide(to, slideSpeed) {\n      // do nothing if already on requested slide\n      if (index == to) return;\n\n      if (browser.transitions) {\n        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\n        // get the actual position of the slide\n\n        if (continuous) {\n          var natural_direction = direction;\n          direction = -slidePos[circle(to)] / width; // if going forward but to < index, use to = slides.length + to\n          // if going backward but to > index, use to = -slides.length + to\n\n          if (direction !== natural_direction) to = -direction * slides.length + to;\n        }\n\n        var diff = Math.abs(index - to) - 1; // move all the slides between index and to in the right direction\n\n        while (diff--) {\n          move(circle((to > index ? to : index) - diff - 1), width * direction, 0);\n        }\n\n        to = circle(to);\n        move(index, width * direction, slideSpeed || speed);\n        move(to, 0, slideSpeed || speed);\n        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n      } else {\n        to = circle(to);\n        animate(index * -width, to * -width, slideSpeed || speed); //no fallback for a circular continuous if the browser does not accept transitions\n      }\n\n      index = to;\n      offloadFn(options.callback && options.callback(index, slides[index]));\n    }\n\n    function move(index, dist, speed) {\n      translate(index, dist, speed);\n      slidePos[index] = dist;\n    }\n\n    function translate(index, dist, speed) {\n      var slide = slides[index];\n      var style = slide && slide.style;\n      if (!style) return;\n      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';\n      style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n      style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';\n    }\n\n    function animate(from, to, speed) {\n      // if not an animation, just reposition\n      if (!speed) {\n        element.style.left = to + 'px';\n        return;\n      }\n\n      var start = +new Date();\n      var timer = setInterval(function () {\n        var timeElap = +new Date() - start;\n\n        if (timeElap > speed) {\n          element.style.left = to + 'px';\n          if (delay) begin();\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n          clearInterval(timer);\n          return;\n        }\n\n        element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + 'px';\n      }, 4);\n    } // setup auto slideshow\n\n\n    var delay = options.auto || 0;\n    var interval;\n\n    function begin() {\n      clearTimeout(interval);\n      interval = setTimeout(_next, delay);\n    }\n\n    function _stop() {\n      delay = 0;\n      clearTimeout(interval);\n    } // setup initial vars\n\n\n    var _start = {};\n    var delta = {};\n    var isScrolling; // setup event capturing\n\n    var events = {\n      handleEvent: function handleEvent(event) {\n        switch (event.type) {\n          case 'touchstart':\n            this.start(event);\n            break;\n\n          case 'touchmove':\n            this.move(event);\n            break;\n\n          case 'touchend':\n            offloadFn(this.end(event));\n            break;\n\n          case 'webkitTransitionEnd':\n          case 'msTransitionEnd':\n          case 'oTransitionEnd':\n          case 'otransitionend':\n          case 'transitionend':\n            offloadFn(this.transitionEnd(event));\n            break;\n\n          case 'resize':\n            offloadFn(_setup);\n            break;\n        }\n\n        if (options.stopPropagation) event.stopPropagation();\n      },\n      start: function start(event) {\n        var touches = event.touches[0]; // measure start values\n\n        _start = {\n          // get initial touch coords\n          x: touches.pageX,\n          y: touches.pageY,\n          // store time to determine touch duration\n          time: +new Date()\n        }; // used for testing first move event\n\n        isScrolling = undefined; // reset delta and end measurements\n\n        delta = {}; // attach touchmove and touchend listeners\n\n        element.addEventListener('touchmove', this, false);\n        element.addEventListener('touchend', this, false);\n      },\n      move: function move(event) {\n        // ensure swiping with one touch and not pinching\n        if (event.touches.length > 1 || event.scale && event.scale !== 1) return;\n        if (options.disableScroll) return;\n        var touches = event.touches[0]; // measure change in x and y\n\n        delta = {\n          x: touches.pageX - _start.x,\n          y: touches.pageY - _start.y\n        }; // determine if scrolling test has run - one time test\n\n        if (typeof isScrolling == 'undefined') {\n          isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));\n        } // if user is not trying to scroll vertically\n\n\n        if (!isScrolling) {\n          // prevent native scrolling\n          event.preventDefault(); // stop slideshow\n\n          _stop(); // increase resistance if first or last slide\n\n\n          if (continuous) {\n            // we don't add resistance at the end\n            translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);\n          } else {\n            delta.x = delta.x / (!index && delta.x > 0 || // if first slide and sliding left\n            index == slides.length - 1 && // or if last slide and sliding right\n            delta.x < 0 // and if sliding at all\n            ? Math.abs(delta.x) / width + 1 // determine resistance level\n            : 1); // no resistance if false\n            // translate 1:1\n\n            translate(index - 1, delta.x + slidePos[index - 1], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(index + 1, delta.x + slidePos[index + 1], 0);\n          }\n\n          options.swiping && options.swiping(-delta.x / width);\n        }\n      },\n      end: function end(event) {\n        // measure duration\n        var duration = +new Date() - _start.time; // determine if slide attempt triggers next/prev slide\n\n        var isValidSlide = Number(duration) < 250 && // if slide duration is less than 250ms\n        Math.abs(delta.x) > 20 || // and if slide amt is greater than 20px\n        Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width\n        // determine if slide attempt is past start and end\n\n        var isPastBounds = !index && delta.x > 0 || // if first slide and slide amt is greater than 0\n        index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0\n\n        if (continuous) isPastBounds = false; // determine direction of swipe (true:right, false:left)\n\n        var direction = delta.x < 0; // if not scrolling vertically\n\n        if (!isScrolling) {\n          if (isValidSlide && !isPastBounds) {\n            if (direction) {\n              if (continuous) {\n                // we need to get the next in this direction in place\n                move(circle(index - 1), -width, 0);\n                move(circle(index + 2), width, 0);\n              } else {\n                move(index - 1, -width, 0);\n              }\n\n              move(index, slidePos[index] - width, speed);\n              move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);\n              index = circle(index + 1);\n            } else {\n              if (continuous) {\n                // we need to get the next in this direction in place\n                move(circle(index + 1), width, 0);\n                move(circle(index - 2), -width, 0);\n              } else {\n                move(index + 1, width, 0);\n              }\n\n              move(index, slidePos[index] + width, speed);\n              move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);\n              index = circle(index - 1);\n            }\n\n            options.callback && options.callback(index, slides[index]);\n          } else {\n            if (continuous) {\n              move(circle(index - 1), -width, speed);\n              move(index, 0, speed);\n              move(circle(index + 1), width, speed);\n            } else {\n              move(index - 1, -width, speed);\n              move(index, 0, speed);\n              move(index + 1, width, speed);\n            }\n          }\n        } // kill touchmove and touchend event listeners until touchstart called again\n\n\n        element.removeEventListener('touchmove', events, false);\n        element.removeEventListener('touchend', events, false);\n        element.removeEventListener('touchforcechange', function () {}, false);\n      },\n      transitionEnd: function transitionEnd(event) {\n        if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n          if (delay) begin();\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n        }\n      }\n    }; // trigger setup\n\n    _setup(); // start auto slideshow if applicable\n\n\n    if (delay) begin(); // add event listeners\n\n    if (browser.addEventListener) {\n      // set touchstart event on element\n      if (browser.touch) {\n        element.addEventListener('touchstart', events, false);\n        element.addEventListener('touchforcechange', function () {}, false);\n      }\n\n      if (browser.transitions) {\n        element.addEventListener('webkitTransitionEnd', events, false);\n        element.addEventListener('msTransitionEnd', events, false);\n        element.addEventListener('oTransitionEnd', events, false);\n        element.addEventListener('otransitionend', events, false);\n        element.addEventListener('transitionend', events, false);\n      } // set resize event on window\n\n\n      window.addEventListener('resize', events, false);\n    } else {\n      window.onresize = function () {\n        _setup();\n      }; // to play nice with old IE\n\n    } // expose the Swipe API\n\n\n    return {\n      setup: function setup() {\n        _setup();\n      },\n      slide: function slide(to, speed) {\n        // cancel slideshow\n        _stop();\n\n        _slide(to, speed);\n      },\n      prev: function prev() {\n        // cancel slideshow\n        _stop();\n\n        _prev();\n      },\n      next: function next() {\n        // cancel slideshow\n        _stop();\n\n        _next();\n      },\n      stop: function stop() {\n        // cancel slideshow\n        _stop();\n      },\n      getPos: function getPos() {\n        // return current index position\n        return index;\n      },\n      getNumSlides: function getNumSlides() {\n        // return total number of slides\n        return length;\n      },\n      kill: function kill() {\n        // cancel slideshow\n        _stop(); // reset element\n\n\n        element.style.width = '';\n        element.style.left = ''; // reset slides\n\n        var pos = slides.length;\n\n        while (pos--) {\n          var slide = slides[pos];\n          slide.style.width = '';\n          slide.style.left = '';\n          if (browser.transitions) translate(pos, 0, 0);\n        } // removed event listeners\n\n\n        if (browser.addEventListener) {\n          // remove current event listeners\n          element.removeEventListener('touchstart', events, false);\n          element.removeEventListener('webkitTransitionEnd', events, false);\n          element.removeEventListener('msTransitionEnd', events, false);\n          element.removeEventListener('oTransitionEnd', events, false);\n          element.removeEventListener('otransitionend', events, false);\n          element.removeEventListener('transitionend', events, false);\n          window.removeEventListener('resize', events, false);\n        } else {\n          window.onresize = null;\n        }\n      }\n    };\n  };\n});","map":{"version":3,"sources":["/Users/yueshanlin/Documents/capstoneProject/node_modules/swipe-js-iso/swipe.js"],"names":["root","factory","module","exports","Swipe","container","options","noop","offloadFn","fn","setTimeout","browser","addEventListener","window","touch","DocumentTouch","document","transitions","temp","props","i","style","undefined","createElement","element","children","slides","slidePos","width","length","index","parseInt","startSlide","speed","widthOfSiblingSlidePreview","continuous","setup","Array","Math","round","getBoundingClientRect","offsetWidth","pos","slide","setAttribute","left","move","circle","visibility","prev","next","to","slideSpeed","direction","abs","natural_direction","diff","animate","callback","dist","translate","webkitTransitionDuration","MozTransitionDuration","msTransitionDuration","OTransitionDuration","transitionDuration","webkitTransform","msTransform","MozTransform","OTransform","from","start","Date","timer","setInterval","timeElap","delay","begin","transitionEnd","call","event","clearInterval","floor","auto","interval","clearTimeout","stop","delta","isScrolling","events","handleEvent","type","end","stopPropagation","touches","x","pageX","y","pageY","time","scale","disableScroll","preventDefault","swiping","duration","isValidSlide","Number","isPastBounds","removeEventListener","target","getAttribute","onresize","getPos","getNumSlides","kill"],"mappings":"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","sourcesContent":["/*\n * Swipe 2.0.0\n * Brad Birdsall\n * https://github.com/thebird/Swipe\n * Copyright 2013-2015, MIT License\n *\n */\n\n(function(root, factory) {\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Swipe = factory();\n  }\n})(this, function() {\n  'use strict';\n\n  return function Swipe(container, options) {\n    // utilities\n    var noop = function() {}; // simple no operation function\n    var offloadFn = function(fn) {\n      setTimeout(fn || noop, 0);\n    }; // offload a functions execution\n\n    // check browser capabilities\n    var browser = {\n      addEventListener: !!window.addEventListener,\n      touch:\n        'ontouchstart' in window ||\n        (window.DocumentTouch && document instanceof window.DocumentTouch),\n      transitions: (function(temp) {\n        var props = [\n          'transitionProperty',\n          'WebkitTransition',\n          'MozTransition',\n          'OTransition',\n          'msTransition'\n        ];\n        for (var i in props)\n          if (temp.style[props[i]] !== undefined) return true;\n        return false;\n      })(document.createElement('swipe'))\n    };\n\n    // quit if no root element\n    if (!container) return;\n    var element = container.children[0];\n    var slides, slidePos, width, length;\n    options = options || {};\n    var index = parseInt(options.startSlide, 10) || 0;\n    var speed = options.speed || 300;\n    var widthOfSiblingSlidePreview =\n      parseInt(options.widthOfSiblingSlidePreview, 10) || 0;\n    var continuous = (options.continuous =\n      options.continuous !== undefined ? options.continuous : true);\n\n    function setup() {\n      // cache slides\n      slides = element.children;\n      length = slides.length;\n\n      // set continuous to false if only one slide\n      continuous = slides.length < 2 ? false : options.continuous;\n\n      // create an array to store current positions of each slide\n      slidePos = new Array(slides.length);\n\n      // determine width of each slide\n      width =\n        Math.round(\n          container.getBoundingClientRect().width || container.offsetWidth\n        ) -\n        widthOfSiblingSlidePreview * 2;\n\n      element.style.width = slides.length * width + 'px';\n\n      // stack elements\n      var pos = slides.length;\n      while (pos--) {\n        var slide = slides[pos];\n\n        slide.style.width = width + 'px';\n        slide.setAttribute('data-index', pos);\n\n        if (browser.transitions) {\n          slide.style.left = pos * -width + widthOfSiblingSlidePreview + 'px';\n          move(pos, index > pos ? -width : index < pos ? width : 0, 0);\n        }\n      }\n\n      // reposition elements before and after index\n      if (continuous && browser.transitions) {\n        move(circle(index - 1), -width, 0);\n        move(circle(index + 1), width, 0);\n      }\n\n      if (!browser.transitions)\n        element.style.left = index * -width + widthOfSiblingSlidePreview + 'px';\n\n      container.style.visibility = 'visible';\n    }\n\n    function prev() {\n      if (continuous) slide(index - 1);\n      else if (index) slide(index - 1);\n    }\n\n    function next() {\n      if (continuous) slide(index + 1);\n      else if (index < slides.length - 1) slide(index + 1);\n    }\n\n    function circle(index) {\n      // a simple positive modulo using slides.length\n      return (slides.length + (index % slides.length)) % slides.length;\n    }\n\n    function slide(to, slideSpeed) {\n      // do nothing if already on requested slide\n      if (index == to) return;\n\n      if (browser.transitions) {\n        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\n\n        // get the actual position of the slide\n        if (continuous) {\n          var natural_direction = direction;\n          direction = -slidePos[circle(to)] / width;\n\n          // if going forward but to < index, use to = slides.length + to\n          // if going backward but to > index, use to = -slides.length + to\n          if (direction !== natural_direction)\n            to = -direction * slides.length + to;\n        }\n\n        var diff = Math.abs(index - to) - 1;\n\n        // move all the slides between index and to in the right direction\n        while (diff--)\n          move(\n            circle((to > index ? to : index) - diff - 1),\n            width * direction,\n            0\n          );\n\n        to = circle(to);\n\n        move(index, width * direction, slideSpeed || speed);\n        move(to, 0, slideSpeed || speed);\n\n        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n      } else {\n        to = circle(to);\n        animate(index * -width, to * -width, slideSpeed || speed);\n        //no fallback for a circular continuous if the browser does not accept transitions\n      }\n\n      index = to;\n      offloadFn(options.callback && options.callback(index, slides[index]));\n    }\n\n    function move(index, dist, speed) {\n      translate(index, dist, speed);\n      slidePos[index] = dist;\n    }\n\n    function translate(index, dist, speed) {\n      var slide = slides[index];\n      var style = slide && slide.style;\n\n      if (!style) return;\n\n      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration =\n        speed + 'ms';\n\n      style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n      style.msTransform = style.MozTransform = style.OTransform =\n        'translateX(' + dist + 'px)';\n    }\n\n    function animate(from, to, speed) {\n      // if not an animation, just reposition\n      if (!speed) {\n        element.style.left = to + 'px';\n        return;\n      }\n\n      var start = +new Date();\n\n      var timer = setInterval(function() {\n        var timeElap = +new Date() - start;\n\n        if (timeElap > speed) {\n          element.style.left = to + 'px';\n\n          if (delay) begin();\n\n          options.transitionEnd &&\n            options.transitionEnd.call(event, index, slides[index]);\n\n          clearInterval(timer);\n          return;\n        }\n\n        element.style.left =\n          (to - from) * (Math.floor((timeElap / speed) * 100) / 100) +\n          from +\n          'px';\n      }, 4);\n    }\n\n    // setup auto slideshow\n    var delay = options.auto || 0;\n    var interval;\n\n    function begin() {\n      clearTimeout(interval);\n      interval = setTimeout(next, delay);\n    }\n\n    function stop() {\n      delay = 0;\n      clearTimeout(interval);\n    }\n\n    // setup initial vars\n    var start = {};\n    var delta = {};\n    var isScrolling;\n\n    // setup event capturing\n    var events = {\n      handleEvent: function(event) {\n        switch (event.type) {\n          case 'touchstart':\n            this.start(event);\n            break;\n          case 'touchmove':\n            this.move(event);\n            break;\n          case 'touchend':\n            offloadFn(this.end(event));\n            break;\n          case 'webkitTransitionEnd':\n          case 'msTransitionEnd':\n          case 'oTransitionEnd':\n          case 'otransitionend':\n          case 'transitionend':\n            offloadFn(this.transitionEnd(event));\n            break;\n          case 'resize':\n            offloadFn(setup);\n            break;\n        }\n\n        if (options.stopPropagation) event.stopPropagation();\n      },\n      start: function(event) {\n        var touches = event.touches[0];\n\n        // measure start values\n        start = {\n          // get initial touch coords\n          x: touches.pageX,\n          y: touches.pageY,\n\n          // store time to determine touch duration\n          time: +new Date()\n        };\n\n        // used for testing first move event\n        isScrolling = undefined;\n\n        // reset delta and end measurements\n        delta = {};\n\n        // attach touchmove and touchend listeners\n        element.addEventListener('touchmove', this, false);\n        element.addEventListener('touchend', this, false);\n      },\n      move: function(event) {\n        // ensure swiping with one touch and not pinching\n        if (event.touches.length > 1 || (event.scale && event.scale !== 1))\n          return;\n\n        if (options.disableScroll) return;\n\n        var touches = event.touches[0];\n\n        // measure change in x and y\n        delta = {\n          x: touches.pageX - start.x,\n          y: touches.pageY - start.y\n        };\n\n        // determine if scrolling test has run - one time test\n        if (typeof isScrolling == 'undefined') {\n          isScrolling = !!(\n            isScrolling || Math.abs(delta.x) < Math.abs(delta.y)\n          );\n        }\n\n        // if user is not trying to scroll vertically\n        if (!isScrolling) {\n          // prevent native scrolling\n          event.preventDefault();\n\n          // stop slideshow\n          stop();\n\n          // increase resistance if first or last slide\n          if (continuous) {\n            // we don't add resistance at the end\n\n            translate(\n              circle(index - 1),\n              delta.x + slidePos[circle(index - 1)],\n              0\n            );\n            translate(index, delta.x + slidePos[index], 0);\n            translate(\n              circle(index + 1),\n              delta.x + slidePos[circle(index + 1)],\n              0\n            );\n          } else {\n            delta.x =\n              delta.x /\n              ((!index && delta.x > 0) || // if first slide and sliding left\n              (index == slides.length - 1 && // or if last slide and sliding right\n                delta.x < 0) // and if sliding at all\n                ? Math.abs(delta.x) / width + 1 // determine resistance level\n                : 1); // no resistance if false\n\n            // translate 1:1\n            translate(index - 1, delta.x + slidePos[index - 1], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(index + 1, delta.x + slidePos[index + 1], 0);\n          }\n          options.swiping && options.swiping(-delta.x / width);\n        }\n      },\n      end: function(event) {\n        // measure duration\n        var duration = +new Date() - start.time;\n\n        // determine if slide attempt triggers next/prev slide\n        var isValidSlide =\n          (Number(duration) < 250 && // if slide duration is less than 250ms\n            Math.abs(delta.x) > 20) || // and if slide amt is greater than 20px\n          Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width\n\n        // determine if slide attempt is past start and end\n        var isPastBounds =\n          (!index && delta.x > 0) || // if first slide and slide amt is greater than 0\n          (index == slides.length - 1 && delta.x < 0); // or if last slide and slide amt is less than 0\n\n        if (continuous) isPastBounds = false;\n\n        // determine direction of swipe (true:right, false:left)\n        var direction = delta.x < 0;\n\n        // if not scrolling vertically\n        if (!isScrolling) {\n          if (isValidSlide && !isPastBounds) {\n            if (direction) {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index - 1), -width, 0);\n                move(circle(index + 2), width, 0);\n              } else {\n                move(index - 1, -width, 0);\n              }\n\n              move(index, slidePos[index] - width, speed);\n              move(\n                circle(index + 1),\n                slidePos[circle(index + 1)] - width,\n                speed\n              );\n              index = circle(index + 1);\n            } else {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index + 1), width, 0);\n                move(circle(index - 2), -width, 0);\n              } else {\n                move(index + 1, width, 0);\n              }\n\n              move(index, slidePos[index] + width, speed);\n              move(\n                circle(index - 1),\n                slidePos[circle(index - 1)] + width,\n                speed\n              );\n              index = circle(index - 1);\n            }\n\n            options.callback && options.callback(index, slides[index]);\n          } else {\n            if (continuous) {\n              move(circle(index - 1), -width, speed);\n              move(index, 0, speed);\n              move(circle(index + 1), width, speed);\n            } else {\n              move(index - 1, -width, speed);\n              move(index, 0, speed);\n              move(index + 1, width, speed);\n            }\n          }\n        }\n\n        // kill touchmove and touchend event listeners until touchstart called again\n        element.removeEventListener('touchmove', events, false);\n        element.removeEventListener('touchend', events, false);\n        element.removeEventListener('touchforcechange', function() {}, false);\n      },\n      transitionEnd: function(event) {\n        if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n          if (delay) begin();\n\n          options.transitionEnd &&\n            options.transitionEnd.call(event, index, slides[index]);\n        }\n      }\n    };\n\n    // trigger setup\n    setup();\n\n    // start auto slideshow if applicable\n    if (delay) begin();\n\n    // add event listeners\n    if (browser.addEventListener) {\n      // set touchstart event on element\n      if (browser.touch) {\n        element.addEventListener('touchstart', events, false);\n        element.addEventListener('touchforcechange', function() {}, false);\n      }\n\n      if (browser.transitions) {\n        element.addEventListener('webkitTransitionEnd', events, false);\n        element.addEventListener('msTransitionEnd', events, false);\n        element.addEventListener('oTransitionEnd', events, false);\n        element.addEventListener('otransitionend', events, false);\n        element.addEventListener('transitionend', events, false);\n      }\n\n      // set resize event on window\n      window.addEventListener('resize', events, false);\n    } else {\n      window.onresize = function() {\n        setup();\n      }; // to play nice with old IE\n    }\n\n    // expose the Swipe API\n    return {\n      setup: function() {\n        setup();\n      },\n      slide: function(to, speed) {\n        // cancel slideshow\n        stop();\n\n        slide(to, speed);\n      },\n      prev: function() {\n        // cancel slideshow\n        stop();\n\n        prev();\n      },\n      next: function() {\n        // cancel slideshow\n        stop();\n\n        next();\n      },\n      stop: function() {\n        // cancel slideshow\n        stop();\n      },\n      getPos: function() {\n        // return current index position\n        return index;\n      },\n      getNumSlides: function() {\n        // return total number of slides\n        return length;\n      },\n      kill: function() {\n        // cancel slideshow\n        stop();\n\n        // reset element\n        element.style.width = '';\n        element.style.left = '';\n\n        // reset slides\n        var pos = slides.length;\n        while (pos--) {\n          var slide = slides[pos];\n          slide.style.width = '';\n          slide.style.left = '';\n\n          if (browser.transitions) translate(pos, 0, 0);\n        }\n\n        // removed event listeners\n        if (browser.addEventListener) {\n          // remove current event listeners\n          element.removeEventListener('touchstart', events, false);\n          element.removeEventListener('webkitTransitionEnd', events, false);\n          element.removeEventListener('msTransitionEnd', events, false);\n          element.removeEventListener('oTransitionEnd', events, false);\n          element.removeEventListener('otransitionend', events, false);\n          element.removeEventListener('transitionend', events, false);\n          window.removeEventListener('resize', events, false);\n        } else {\n          window.onresize = null;\n        }\n      }\n    };\n  };\n});\n"]},"metadata":{},"sourceType":"script"}